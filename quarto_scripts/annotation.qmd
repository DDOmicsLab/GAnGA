---
title: "Bacterial Genome Analysis Report"
author: "Harshada Pardeshi"
date: "`r Sys.Date()`"
format:
  html: default
execute: 
  freeze: false
editor: visual

---

```{r libraries, include=FALSE, echo=FALSE, warning=FALSE}
options(repos = c(CRAN = "https://cran.rstudio.com/"))
required_packages <- c("knitr", "kableExtra", "dplyr", "BiocManager", "rmarkdown", "rvest", "jsonlite", "readr", "data.table", "xml2","devtools","fastqcr","textshaping","data.table", "ggplot2", "readr","stringr", "tidyr","pheatmap","ggsci")

for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
}
BiocManager::install("ComplexHeatmap")
library("ComplexHeatmap")
file_path <- "absolute_paths.txt"
```

## Annotation

::: panel-tabset
### Gene Prediction

This is the summary of protein-coding genes predicted using [Prodigal](https://github.com/hyattpd/Prodigal).

Prodigal is a protein-coding gene prediction software tool for bacterial and archaeal genomes. The acronym stands for PROkaryotic DYnamic Programming Genefinding ALgorithm. It runs smoothly on finished genomes, draft genomes and metagenomes. Prodigal can handle gaps scaffolds and partial genes if specified by the user. It identifies translation initiation sites and outputs detailed summary statistics for each genome.

Following table generated by Prodigal gives a summary of potential genes (with scores). It includes 13 columns, specifying-

1.  Beg- the starting position of the gene in the sequence
2.  End- the ending position of the gene in the sequence
3.  Std- the strand direction (positive or negative)
4.  Total- the total score assigned to the particular start site based on coding potential and other relevant features to gene prediction
5.  CodPot- this score represents how likely the sequence at this position encodes a functional protein. A higher score suggests a higher likelihood of coding functionality
6.  StrtSc- This value reflects the strength of the start codon at the predicted start site. A higher score means the start site is more likely to be correct
7.  Codon- The start codon (e.g., ATG, GTG, TTG) found at the start position of the gene. Prodigal is capable of recognizing alternative start codons
8.  RBSMot- Ribosome Binding Site (RBS) motif, if applicable, this column shows the motif found near the predicted start site that may serve as a ribosome binding site (e.g., Shine-Dalgarno sequence)
9.  Spacer- The distance between the RBS and the start codon (if an RBS is detected).
10. RBSScr- RBS score, a numerical score indicating the strength of the ribosome binding site. Higher values indicate a stronger RBS signal
11. UpsScr- Upstream score, a score reflecting the likelihood that there is a functional promoter or other regulatory element upstream of the start site
12. TypeScr- Type score, a score related to the classification of the start site, which includes its context and other genomic features around it
13. GCCont- GC content, the percentage of guanine and cytosine nucleotides in the region surrounding the start site

Prodigal output files are stored in `09_prodigal` directory in the specified `outdir`.

Following is the command used for gene prediction in the genome:

``` bash
prodigal  -i {sample_dir/08_pilon/{sample}.fasta} -o {sample_dir/09_prodigal/{sample_name}_genes.gbk} -a {sample_dir/09_prodigal/{sample_name}_proteins.faa} -d {sample_dir/09_prodigal/{sample_name}_gene_sequences} -s {sample_dir}/09_prodigal/{sample_name}.tsv} &> {sample_dir/logs/prodigal.log}
```

```{r prodigal, echo=FALSE}
paths <- readLines(file_path)
prodigal_tsv <- paths[14]

# Read only the first few lines after skipping headers
prodigal_content <- readLines(prodigal_tsv)[-(1:2)]
writeLines(prodigal_content, "temp/prodigal_modified.tsv")

# Load only the first 10 rows
prodigal_table <- read.table("temp/prodigal_modified.tsv", header = TRUE, quote="", sep = "\t", dec = ".")[1:10, ]

# Set column names
colnames(prodigal_table) <- c("Beg", "End", "Std", "Total", "CodPot", "StrtSc", 
                            "Codon", "RBSMot", "Spacer", "RBSScr", 
                            "UpsScr", "TypScr", "GCCont")

# Display the table
kable(prodigal_table, results="asis", align = "c", caption = "Gene prediction (first 10 rows)") %>%
    kable_paper() %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "1000px", height = "600px")
```

Only first 10 lines of the prodigal_tsv file shown above. For more details, Prodigal output files are saved here

| Filename                                                    | Location               | Description                     |
|------------------------------|-------------------|-----------------------|
| [prodigal.tsv](file:// `r file.path(prodigal_tsv)`) | sample_dir/09_prodigal | Summary file of predicted genes |

### Genome annotation

This is standardized annotation of the genome done using [Bakta](https://github.com/oschwengers/bakta).

Bakta is a tool for the robust, thorough, taxon-independent and nonetheless, fast annotation of bacterial genomes and plasmids from both isolates and MAGs. It conducts a comprehensive annotation workflow including the detection of small proteins taking into account replicon metadata. The annotation of coding sequences is accelerated via an alignment-free sequence identification approach that in addition facilitates the precise assignment of public database cross-references. It exports annotations results in machine-readable JSON & bioinformatics standard file formats for automated downstream analysis.

Bakta output files are stored in `10_bakta` directory in the specified `outdir`.

Following is the command used for annotating the genome:

``` bash
bakta {sample_dir/08_pilon/{sample_name}.fasta} --db {current_directory/bakta_db/db} --prefix {sample_name}_bakta --genus {genus_name} --species {species_name} --output {sample_dir/10_bakta} --min-contig-length 200 --compliant --force -t 30 &> {sample_dir/logs/bakta.log}
```

```{r bakta_table,echo=FALSE}
paths <- readLines(file_path)
bakta_txt <- paths[17]
bakta_tsv <- paths[15]

bakta_content <- readLines(bakta_tsv)[-(1:5)]
writeLines(bakta_content, "temp/bakta_modified.tsv")

bakta_table=read.table(file.path("temp/bakta_modified.tsv"), header = T, quote="",sep = "\t", dec = ".", fill = TRUE, comment.char = "")
colnames(bakta_table)=c("#Sequence Id","Type","Start","Stop","Strand","Locus Tag","Gene","Product","DbXrefs")
bakta_table <- bakta_table %>% select(-`DbXrefs`)

bakta_table$Strand[bakta_table$Strand == "+"] <- "forward"
bakta_table$Strand[bakta_table$Strand == "-"] <- "reverse"

kable(bakta_table, results="asis", align = "c", caption = "Genome annotation") %>%
    kable_paper() %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE) %>% # Bold the header row
  scroll_box(width = "1000px", height = "900px")
```





For more details, Bakta output files are saved here

| Filename                                              | Location            | Description                     |
|------------------------------|-------------------|-----------------------|
| [bakta.txt](file://  `r file.path(bakta_txt) `) | sample_dir/10_bakta | Summary file of genomic features (Signal peptide prediction was not enabled) |
| [bakta.tsv](file:// `r file.path(bakta_tsv)`) | sample_dir/10_bakta | Summary file of annotated genes |

### Resistance Genes 

This is the identification of antibiotic resistance genes or resistome(s) done using [Resistance Gene Identifier (RGI)](https://github.com/arpcard/rgi).

RGI is used to predict antibiotic resistome(s) from protein or nucleotide data based on homology and SNP models. The application uses reference data from the [Comprehensive Antibiotic Resistance Database (CARD)](https://card.mcmaster.ca/). RGI supports analysis of genomes, genome assemblies, metagenomic contigs, or proteomes. It additionally supports analysis of metagenomic reads and k-mer prediction of pathogen-of-origin for AMR genes.

RGI output files are stored in `12_rgi` directory in the specified `outdir`.

Following is the command used for identifying the antibiotic resistome of the genome:

``` bash
rgi main -i {sample_dir/08_pilon/{sample_name}.fasta} -o {sample_dir/12_rgi/{sample_name}_rgi} --local --clean --include_loose -n 30 &> {sample_dir/logs/rgi.log}
sed 's/\t\t/\tn\/a\t/g' {sample_dir/12_rgi/{sample_name}_rgi.txt} > {sample_dir/12_rgi/{sample_name}_rgi.tsv}
sed -i 's/#/;/g' {sample_dir/12_rgi/{sample_name}_rgi.tsv}
```

```{r rgi,echo=FALSE}
paths <- readLines(file_path)
rgi_tsv <- paths[19]
rgi_df <- read_tsv(rgi_tsv,show_col_types = FALSE)
setDT(rgi_df)
colnames(rgi_df)=c("ORF_ID","Contig","Start","Stop","Orientation","Cut_Off","Pass_Bitscore","Best_Hit_Bitscore","Best_Hit_ARO","Best_Identities","ARO","Model_type","SNPs_in_Best_Hit_ARO","Other_SNPs","Drug Class","Resistance Mechanism","AMR Gene Family","Predicted_DNA","Predicted_Protein","CARD_Protein_Sequence","Percentage Length of Reference Sequence","ID","Model_ID","Nudged","Note","Hit_Start","Hit_End","Antibiotic", "AST_Source")
rgi_df <- rgi_df %>% select(-`ORF_ID`,-`Pass_Bitscore`,-`Best_Hit_Bitscore`,-`Best_Identities`,-`ARO`,-`Model_type`,-`SNPs_in_Best_Hit_ARO`,-`Other_SNPs`,-`Predicted_DNA`,-`Predicted_Protein`,-`CARD_Protein_Sequence`,-`Percentage Length of Reference Sequence`,-`ID`,-`Model_ID`,-`Nudged`,-`Note`,-`Hit_Start`,-`Hit_End`,-`Antibiotic`, -`AST_Source`)
rgi_df$Orientation[rgi_df$Orientation == "+"] <- "forward"
rgi_df$Orientation[rgi_df$Orientation == "-"] <- "reverse"
kable(rgi_df,results="asis",align = "c",escape = FALSE, caption = "Antibiotic resistance genes") %>%
    kable_styling(full_width = FALSE, position = "center", bootstrap_options = "striped") %>%
    row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "1000px" , height = "900px")
```

```{r rgi_histogram,echo=FALSE, fig.cap="Distribution of genes resistant to each drug class based on RGI analysis"}

# Read the RGI TSV file
paths <- readLines(file_path)
rgi_tsv <- paths[19]
rgi_data <- read.table(rgi_tsv, header = TRUE, fill = TRUE, quote = "", sep = "\t")
#str(rgi_data)

# Select columns 10 and 15 (Best_Hit_ARO and Drug.Class respectively)
rgi_subset <- rgi_data %>%
  select(Best_Hit_ARO, Drug.Class)

# Separate the Drug.Class column by commas, creating one row per drug class per gene
rgi_data_separated <- rgi_subset %>%
  separate_rows(Drug.Class, sep = ";\\s*")  # Split by comma and optional space

# Count the unique Best_Hit_ARO genes for each drug class
histogram_data <- rgi_data_separated %>%
  group_by(`Drug.Class`, Best_Hit_ARO) %>%
  summarise(num_genes = n(), .groups = 'drop') %>%
  group_by(`Drug.Class`) %>%
  summarise(total_genes = n_distinct(Best_Hit_ARO), .groups = 'drop') %>%
  arrange(desc(total_genes))

# Create a histogram
ggplot(histogram_data, aes(x = reorder(`Drug.Class`, -total_genes), y = total_genes, fill = total_genes)) +
  geom_bar(stat = "identity") + 
  scale_fill_gradient(low = "lightblue", high = "darkblue") +
  labs(title = "Number of Genes Resistant to Each Drug Class",
       x = "Drug Class",
       y = "Number of Resistant Genes") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
        axis.text.y = element_text(size = 8),
        axis.title = element_text(size = 14),  # Change axis label font size
        plot.title = element_text(hjust = 0.5, face = "bold", size = 14))+
  coord_flip()


```

For more details, RGI output files are saved here

| Filename                                          | Location          | Description                  |
|------------------------------|-------------------|-----------------------|
| [rgi.tsv](file:// `r file.path(rgi_tsv)`) | sample_dir/12_rgi | TSV file of resistance genes |


### Mobile Genetic Elements

This is the summary and table of all detected MGE hits in each contig. Detection of MGEs is done using [mobileOG-db](https://github.com/clb21565/mobileOG-db).

mobileOG-db (for mobile orthologous groups) is a manually curated database of protein families mediating the integration/excision, replication/recombination/repair, stability/defense, or transfer of bacterial mobile genetic elements and phages as well as the associated transcriptional regulators of these processes. mobileOG-db was created in a process involving more than 15,000 unique manual curation events, with 1,558 references and 2,444 unique manual functional annotations at present.

mobileOG-db output files are stored in `15_mobileog` directory in the specified `outdir`.

Following is the command used for identifying the MGEs in the genome:

``` bash
if [ ! -d "{sample_dir/15_mobileog/}" ]; then 
mkdir {sample_dir/15_mobileog/}
fi
cd mobileOg/mobileOG-db-main/mobileOG-pl
bash {current_directory/mobileOg/mobileOG-db-main/mobileOG-pl/mobileOGs-pl-kyanite.sh} -i {sample_dir/08_pilon/{sample_name}.fasta} -d {current_directory/mobileOg/mobileOG-db-main/mobileog_db.dmnd} -m {current_directory/mobileOg/mobileOG-db-main/mobileog_db.csv} -k 15 -e 1e-20 -p 90 -q 90 &> {sample_dir/logs/mobileog.log}
cd {current_directory}
mv {sample_dir/08_pilon/{sample_name}.fasta.mobileOG.Alignment.Out.csv} {sample_dir/15_mobileog/{sample_name}.fasta.mobileOG.Alignment.Out.csv}
mv {sample_dir/08_pilon/{sample_name}.fasta.summary.csv} {sample_dir/15_mobileog/{sample_name}.fasta.summary.csv}
mv {sample_dir/08_pilon/{sample_name}.fasta.tsv} {sample_dir/15_mobileog/{sample_name}.fasta.tsv}
```

```{r mobileog_summary, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
paths <- readLines(file_path)
mobileog_summary_csv <- paths[22]
mobileog_df <- read_csv(mobileog_summary_csv,show_col_types = FALSE)
setDT(mobileog_df)
mobileog_df <- mobileog_df[ , -1]
colnames(mobileog_df) <- c("Specific.Contig", "Bacteriophages", "Insertion.Sequences", "Integrative.elements", "Mulitple", "Plasmids", "Total.Number.of.Hits", "Percent.Bacteriophages", "Percent.Insertion.Sequences", "Percent.Integrative.elements", "Percent.Plasmids", "Percent.Multiple", "Amount.of.Unique.ORFs")
kable(mobileog_df,results="asis",align = "c",escape = FALSE, caption = "Summary of detected MGE hits") %>%
    kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>%
    row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "1500px" , height = "600px")
```

```{r mobileog_summary_pie, echo=FALSE, message=FALSE}
paths <- readLines(file_path)
mobileog_summary_csv <- paths[22]
colnames(df)

df <- read_csv(mobileog_summary_csv,show_col_types = FALSE)
mge_count <- df %>%
  summarize(
    Bacteriophages=sum(Bacteriophages),
    Insertion_sequences=sum(`Insertion sequences`),
    Integrative_elements=sum(`Integrative elements`),
    Plasmids=sum(Plasmids),
    Multiple=sum(Multiple),
    Amount_of_Unique_ORFs=sum(`Amount of Unique ORFs`)
      )%>%
  pivot_longer(cols = everything(), names_to = "MGE_category", values_to = "Count")

#print(mge_count)

total_count <- sum(mge_count$Count)
mge_count$Percentage <- ( mge_count$Count / total_count) * 100

#print(mge_count$Percentage)

# Plot the pie chart
ggplot(mge_count, aes(x = "", y = Count, fill = MGE_category)) +
  geom_bar(stat = "identity", width = 1, color="white") +
  coord_polar(theta = "y") +
  labs(title = "Abundance of Mobile Genetic Elements", fill = "MGE_category") +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16)) +
  #geom_text(aes(x=1.6, label = scales::percent(Percentage, accuracy = .5)), position = position_stack(vjust = .5)) +
  geom_text(aes(x=1.6, label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.7), 
            color = "black", size = 3) +
  coord_polar("y") +
  scale_fill_manual(values = c(
    "Plasmids"="#7c6f3c", 
    "Bacteriophages"="#C9CC3F", 
    "Insertion_sequences"="#4DAF4A", 
    "Integrative_elements"="#0024c6", 
    "Multiple"="#957DFF", 
    "Amount_of_Unique_ORFs"="#FEE685"
  ))
```


```{r mobileog_detailed_table, echo=FALSE, message = FALSE}

paths <- readLines(file_path)
mobileog_detailed_csv <- paths[23]

mobileog_df <- read_csv(mobileog_detailed_csv, show_col_types=FALSE)
setDT(mobileog_df)

filtered_mobileog <- mobileog_df %>%
  filter(Pident >= 95)

filtered_mobileog <- filtered_mobileog %>% select(`Gene Name`, `Pident`, `Major mobileOG Category`)%>%
  arrange(desc(Pident))

kable(filtered_mobileog,results="asis",align = "c",escape = FALSE, caption = "Genes (>=95% Pident) belonging to Major mobileOG Category") %>%
    kable_styling(full_width = FALSE, position = "center", bootstrap_options = "striped") %>%
    row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "1000px" , height = "900px")


```
For more details, mobileOG-db output files are saved here

| Filename                                                                           | Location               | Description                    |
|------------------------------|-------------------|-----------------------|
| [summary.csv](file:// `r file.path(mobileog_summary_csv)`)                 | sample_dir/15_mobileog | Summary of detected MGEs (Used for plotting the above pie chart)      |
| [mobileOG.Alignment.Out.csv](file:// `r file.path(mobileog_detailed_csv)`) | sample_dir/15_mobileog | Detailed file of detected MGEs |

### Prophages 

This is the detection of prophage regions present in the genome done using [Phigaro](https://github.com/bobeobibo/phigaro).

Phigaro is a standalone command-line application that is able to detect prophage regions taking raw genome and metagenome assemblies as an input. It also produces dynamic annotated “prophage genome maps” and marks possible transposon insertion spots inside prophages. It is applicable for mining prophage regions from large metagenomic datasets.

Phigaro output files are stored in `13_phigaro` directory in the specified `outdir`.

Following is the command used for identifying the prophage regions in the genome:

``` bash
phigaro -o {sample_dir/13_phigaro/} -f {sample_dir/08_pilon/{sample_name}.fasta} --save-fasta -d -e tsv html --not-open -t 20 &> {sample_dir/logs/phigaro.log}
```

```{r phigaro, echo=FALSE}
paths <- readLines(file_path)
phigaro_tsv <- paths[21]
phigaro_html <- paths[31]
phigaro_df <- read_tsv(phigaro_tsv, show_col_types = FALSE)
setDT(phigaro_df)
colnames(phigaro_df)=c("scaffold","id","begin","end","transposable","taxonomy")
kable(phigaro_df,results="asis",align = "c",escape = FALSE, caption = "Putative Prophage Regions") %>%
    kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>%
    row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "1000px" , height = "400px")

```

For more details, Phigaro output files are saved here

| Filename                                                  | Location              | Description                           |
|------------------------------|-------------------|-----------------------|
| [phigaro.tsv](file:// `r file.path(phigaro_tsv)`) | sample_dir/13_phigaro | TSV file of detected prophage regions |
| [phigaro.html](file:// `r file.path(phigaro_html)`) | sample_dir/13_phigaro | HTML file of detected prophage regions |

### CRISPR-Cas Cassettes

This is the identification of the CRISPR-Cas Cassettes present in the genome done using [CRISPRcasIdentifier](https://github.com/BackofenLab/CRISPRcasIdentifier).

CRISPRcasIdentifier is an effective machine learning approach for the identification and classification of CRISPR-Cas systems. It consists of a holistic strategy which allows us to: (i) combine regression and classification approaches for improving the quality of the input protein cassettes and predicting their subtypes with high accuracy; (ii) to detect signature genes for the different subtypes; (iii) to extract several types of information for each protein, such as potential rules that reveal the identity of neighboring genes; and (iv) define a complete and extensible framework able to integrate newly discovered Cas proteins and CRISPR subtypes.

CRISPRcasIdentifier output files are stored in `16_crispr` directory in the specified `outdir`.

Following is the command used for finding the CRISPR-Cas Cassettes in the genome:

``` bash
cd crispr/CRISPRcasIdentifier-1.1.0
python CRISPRcasIdentifier.py -f {sample_dir/08_pilon/{sample_name}.fasta} -st dna -sc partial -o {sample_dir/16_crispr/{sample_name}_crispr_prediction.csv} &> {sample_dir/logs/{sample_name}_crispr.log}
cd {current_directory}
```

```{r crispr, echo=FALSE}
paths <- readLines(file_path)
crispr_csv <- paths[24]
crispr<-read_csv(crispr_csv,show_col_types=FALSE)
colnames=c("HMM","cassette_id","classifier","regressor","predicted_label")
crispr <- crispr %>% select(-`HMM`,-`classifier`,-`regressor`)
kable(crispr,results="asis",align="c",escape=FALSE, caption = "Predicted CRISPR cassettes")
```

```{r crispr_linear_graph, echo=FALSE, fig.width=16}
paths <- readLines(file_path)
crispr_csv <- paths[24]
df<-read_csv(crispr_csv,show_col_types=FALSE)
crispr_data <- data.frame(file_path)
# Create the linear genome diagram using ggplot2

  ggplot(df, aes(x = cassette_id, y = 1, fill = predicted_label)) +
    geom_tile(height = 0.3, color = "white") +  # Adjust height as needed
    labs(title = "Predicted CRISPR-Cas Cassettes", fill = "MGE_category") +
    theme_void() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16)) +
    geom_text(aes(label = predicted_label), vjust = 0.5, size = 4) +
    scale_x_continuous(breaks = crispr_data$cassette_id, labels = crispr_data$cassette_id) +
    scale_y_continuous(breaks = NULL) + # Remove y-axis labels and ticks
    labs(x = "Cassette ID", y = "", fill = "Cas System Type") +
    scale_fill_npg() +
    #scale_fill_brewer(palette = "Paired") + 
    #scale_fill_manual(values = c(
    #"CAS-VI-B" = "#00BFC4",  # Cyan
    #"CAS-V-B"  = "#66A61E",  # Green
    #"CAS-V-A"  = "#E15759"   # Red
  #)) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 20),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 8),
      axis.title.x = element_text(size = 14),
      axis.title.y = element_text(size = 14),
      legend.title = element_text(size = 13, face = "bold"),
      legend.text = element_text(size = 11),
      axis.ticks.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.y = element_blank(),
      panel.grid.major.x = element_line(color = "gray90"),
      legend.position = "bottom",
      plot.margin = margin(2, 2, 2, 2)  # Reduce outer margins
    ) +
  coord_cartesian(ylim = c(0.2, 2.0))  # Shrink vertical space

```

For more details, CRISPRcasIdentifier output files are saved here

| Filename                                                           | Location             | Description                      |
|------------------------------|-------------------|-----------------------|
| [crispr_prediction.csv](file:// `r file.path(crispr_csv)`) | sample_dir/16_crispr | CSV file of detected CRISPR hits |


### Virulence

This is the identification of virulence genes present in the genome done using [PanViTa](https://github.com/dlnrodrigues/panvita).

PanViTa is designed to to make comparisons between multiple genomes and specific databases.The tool uses databases to obtain biological information available through the web, including CARD (Comprehensive Antimicrobial Resistance Database) and BacMet2 (Antibacterial Biocide and Metal Resistance Genes Database) for resistance analysis, and VFDB (Virulence Factor Database) for virulence analysis. The user can select any of the databases initially via the command line.

PanViTa output files are stored in `17_panvita` directory in the specified `outdir`.

Following is the command used for finding virulence genes in the genome:

``` bash
"""
mkdir -p {sample_dir/17_panvita/}
cd {sample_dir/17_panvita/}
python3 {current_directory/panvita/panvita.py} -vfdb {sample_dir/10_bakta/{sample_name}_bakta.gbff} &> {sample_dir/logs/{sample}_panvita.log}
mv Results_vfdb* Results_vfdb
sed -i 's/;/,/g' Results_vfdb/vfdb_mechanisms.csv
sed -i 's/;/,/g' Results_vfdb/matriz_vfdb.csv
cd {current_directory}
"""
```

```{r virulence_mechanism, echo=FALSE, message = FALSE}
paths <- readLines(file_path)
vfdb_mechanisms_csv <- paths[34]
# Read the file and check if it has any data (not just headers)
vir_mech <- tryCatch({
  read_csv(vfdb_mechanisms_csv, show_col_types = FALSE)
}, error = function(e) NULL)  # Handle file read errors

# Check if the data is empty (only headers with no content)
if (is.null(vir_mech) || nrow(vir_mech) == 0) {
  cat("No virulence encoding genes present")
} else {
  # Proceed with renaming and displaying the data if it's not empty
  colnames(vir_mech) <- c("Virulence Mechanism", "Number of Core Genes", "Number of Accessory Genes", "Number of Exclusive Genes")
  vir_mech <- vir_mech %>% select(-`Number of Accessory Genes`, -`Number of Exclusive Genes`)
  kable(vir_mech, results = "asis", align = "c", escape = FALSE, caption = "Virulence Mechanisms")
}
```

```{r vfdb_pie, echo=FALSE, message=FALSE}
paths <- readLines(file_path)
vfdb_mechanisms_csv <- paths[34]

if (file.exists(vfdb_mechanisms_csv)) {
  df <- read.csv(vfdb_mechanisms_csv, header = TRUE, row.names = 1, check.names = FALSE)
  df <- data.frame(Category = rownames(df), df, row.names = NULL)

  # Check if 'Core' column is empty or contains only zeros/NA
  if (nrow(df) == 0 || all(is.na(df$Core)) || sum(df$Core, na.rm = TRUE) == 0) {
    cat("No virulence core genes found")
  } else {
    total_core <- sum(df$Core)
    df$Percentage <- (df$Core / total_core) * 100

    ggplot(df, aes(x = "", y = Percentage, fill = Category)) +
      geom_bar(stat = "identity", width = 1, color="white") +
      coord_polar(theta = "y") +
      geom_text(aes(x=1.62, label = paste0(round(Percentage, 1), "%")), 
                position = position_stack(vjust = 0.7), 
                color = "black", size = 3) +
      scale_fill_manual(values = c(
        "Nutritional/Metabolic factor" = "#FF7F50",
        "Biofilm" = "#808080",
        "Immune modulation" = "#C2B280",
        "Motility" = "cornflowerblue",
        "Adherence" = "#C9CC3F",
        "Regulation" = "azure2",
        "Invasion" = "#E0B0FF",
        "Effector delivery system" = "#E49B0F",
        "Antimicrobial activity/competitive advantage" = "#FADA5E",
        "Exotoxin" = "#7c6f3c", 
        "Exoenzyme" = "cadetblue3", 
        "Stress survival" = "darkseagreen3", 
        "Post Transaltional Modifications" = "darksalmon", 
        "Others" = "antiquewhite"
      )) +
      labs(title = "Abundance of virulence core genes", fill = "Category") +
      theme_void() +
      theme(legend.position = "right", plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
  }
} else {
  cat("VFDB file not found")
}
```


```{r virulence_matriz, echo=FALSE}
paths <- readLines(file_path)
matriz_vfdb_csv <- paths[35]
# Read the file and check if it has any data (not just headers)
vir_matriz <- tryCatch({
  read_csv(matriz_vfdb_csv, show_col_types = FALSE)
}, error = function(e) NULL)  # Handle file read errors

# Check if the data is empty (only headers with no content)
if (is.null(vir_matriz) || nrow(vir_matriz) == 0) {
  cat("No virulence encoding genes present")
} else {
vir_matriz<- read_csv(matriz_vfdb_csv,show_col_types=FALSE)
vir_matriz[1,1]<- "Percent Identity"
colnames(vir_matriz)[1] = "Genes"
vir_matriz<-t(vir_matriz)
vir_matriz <- vir_matriz[-nrow(vir_matriz),]
kable(vir_matriz, results="asis",align="c",escape=FALSE, caption = "Abundance of virulence genes") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center") %>%
  row_spec(0, bold = TRUE) %>% # Bold the header row
    scroll_box(width = "800px" , height = "400px" )
}
```

```{r vfdb_heatmap_new, echo=FALSE, message=FALSE}
paths <- readLines(file_path)
matriz_vfdb_csv <- paths[35]

vfdb_analysis <- read.csv(matriz_vfdb_csv, header = TRUE, row.names = 1, sep = ",")

transposed_df <- data.frame(t(vfdb_analysis))


filtered_df <- transposed_df %>%
filter(if_any(everything(), ~ .x >= 95))

if (nrow(filtered_df) > 0 && ncol(filtered_df) > 0) {

final <- t(filtered_df)
unique_vals <- unique(as.numeric(final))

if (length(unique_vals) > 1) {
# Define color palette
col_new <- colorRampPalette(c("slateblue", "azure2", "#FADA5E", "tan2"))(50)

# Plot heatmap
Heatmap(as.matrix(final),
        cluster_columns = TRUE, cluster_rows = FALSE,
        column_title = "Virulence genes (≥95% identity)",
        clustering_distance_rows = "euclidean",
        clustering_method_rows = "complete",
        clustering_distance_columns = "euclidean",
        clustering_method_columns = "complete",
        column_dend_height = unit(30, "mm"),
        height = unit(30, "mm"),
        width = unit(120, "mm"),
        show_heatmap_legend = TRUE,
        column_labels = colnames(final),
        column_names_gp = gpar(fontsize = 7, rot = 45),
        column_title_gp = gpar(fontsize = 16, fontface = "bold"),
        row_names_gp = gpar (fontsize = 6),
        col = col_new)

} else {
    # --- Case: only one unique value ---
    cat("⚠️ Only one virulence gene (≥95%) found — heatmap not generated.\n")
  }

} else {
  # --- Case: no genes meet ≥95% threshold ---
  cat("⚠️ No virulence genes with ≥95% identity found. Heatmap not generated.\n")
}

```
For more details, PanViTa output files are saved here

| Filename                                                                  | Location              | Description                               |
|------------------------------|-------------------|-----------------------|
| [vfdb_mechanisms.csv](file:// `r file.path(vfdb_mechanisms_csv)`) | sample_dir/17_panvita | CSV file of detected virulence mechanisms |
| [matriz_vfdb.csv](file:// `r file.path(matriz_vfdb_csv)`)         | sample_dir/17_panvita | CSV file of detected virulence gene hits  |


### Secondary metabolites

This is the identification of secondary metabolites gene clusters present in the genome done using [antiSMASH](https://docs.antismash.secondarymetabolites.org/).

antiSMASH, the **anti**biotics & **S**econdary **M**etabolite **A**nalysis **SH**ell, allows the rapid genome-wide identification, annotation and analysis of secondary metabolite biosynthetis gene clusters (BCGs) in bacterial and fungal genomes.

antiSMASH output files are stored in `19_antismash` directory in the specified `outdir`.

Following is the command used for finding secondary metabolites gene clusters in the genome:

``` bash
antismash -t bacteria --output-dir {sample_dir/19_antismash} --output-basename {sample_name} --genefinding-tool none {sample_dir/10_bakta/{sample_name}_bakta.gbff} --fullhmmer --clusterhmmer --tigrfam --asf --cc-mibig --cb-general --cb-subclusters --cb-knownclusters --pfam2go --rre --smcog-trees --tfbs
```

```{r antismash,echo=FALSE,results="asis"}
paths <- readLines(file_path)
antismash_html <- paths[26]
```

Detailed antiSMASH output is available as an html file. Click on the link below to view results.

| Filename                                                    | Location                | Description                |
|------------------------------|-------------------|-----------------------|
| [index.html](file:// `r file.path(antismash_html)`) | sample_dir/19_antismash | HTML file of detected BCGs |

: antiSMASH output files
:::
